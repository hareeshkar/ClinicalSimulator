import Foundation
import FirebaseAI // This is the ONLY import you need for AI.
final class GeminiService {

    // MARK: - AI Model Initialization (Correct way)
    private let model = FirebaseAI.firebaseAI(backend: .googleAI()).generativeModel(modelName: "gemini-2.5-flash")

    // MARK: - Shared Helper Functions

    /// Creates a unified, time-ordered event log from conversation messages and student actions.
    /// - Parameters:
    ///   - session: The `StudentSession` containing the messages and actions.
    ///   - allStates: A dictionary of all possible states for the case, used to determine the patient's state at each event.
    /// - Returns: A formatted string representing the chronological history of the simulation.
    private func generateChronologicalLog(for session: StudentSession, with allStates: [String: StateDetail]) -> String {
        // 1. Combine conversation and actions into a single timeline.
        let conversationEvents = session.messages.map { (timestamp: $0.timestamp, description: "\($0.sender.capitalized): \($0.content)") }
        let actionEvents = session.performedActions.map { (timestamp: $0.timestamp, description: "[System Event] Student administered: \($0.actionName). Justification: \($0.reason ?? "None provided.")") }
        let allEvents = (conversationEvents + actionEvents).sorted { $0.timestamp < $1.timestamp }

        // 2. Create a map to easily find which state is triggered by which action.
        let triggerToStateMap = allStates.reduce(into: [String: String]()) { result, state in
            if let trigger = state.value.trigger {
                result[trigger] = state.key
            }
        }

        // 3. Determine which actions caused a state change.
        let stateChangeEvents = session.performedActions.compactMap { action -> (Date, String)? in
            guard let triggeredStateName = triggerToStateMap[action.actionName] else { return nil }
            return (action.timestamp, triggeredStateName)
        }.sorted { $0.0 < $1.0 }

        // 4. Build the final log string, including the patient's state at the time of each event.
        let chronologicalLog = allEvents.map { event in
            // Find the most recent state change that occurred at or before this event's timestamp.
            let activeStateName = stateChangeEvents.last { $0.0 <= event.timestamp }?.1 ?? "initial"
            let timeString = event.timestamp.formatted(date: .omitted, time: .standard)
            return "[\(timeString)] [Patient State: \(activeStateName.capitalized)] \(event.description)"
        }.joined(separator: "\n")

        return chronologicalLog
    }

    // MARK: - Generate Patient Response for Simulation (Streaming)
    // CHANGE: This function no longer returns a single 'String'.
    // It now returns an 'AsyncThrowingStream' that yields string chunks as they are generated by the AI.
    // This allows the UI to display the response word-by-word, creating a "typing" effect.
    func generatePatientResponseStream(
        patientCase: PatientCase,
        session: StudentSession,
        userRole: String = "Medical Student (MS3)" // ✅ NEW: Accept user role
    ) -> AsyncThrowingStream<String, Error> {
        // Decode the case detail if available so we can extract persona info.
        let caseDetail: EnhancedCaseDetail?
        if let data = patientCase.fullCaseJSON.data(using: .utf8) {
            caseDetail = try? JSONDecoder().decode(EnhancedCaseDetail.self, from: data)
        } else {
            caseDetail = nil
        }
        // Build the persona-driven prompt.
        let prompt = buildPatientPrompt(session: session, caseDetail: caseDetail, userRole: userRole)
        // Create and return the streaming wrapper.
        return AsyncThrowingStream { continuation in
            Task {
                do {
                    // Use the single shared model for all AI work (streaming patient output).
                    let contentStream = try model.generateContentStream(prompt)
                    for try await chunk in contentStream {
                        if let text = chunk.text {
                            continuation.yield(text)
                        }
                    }
                    continuation.finish()
                } catch {
                    continuation.finish(throwing: error)
                }
            }
        }
    }
    // ✅ NEW: The new, persona-driven prompt builder for the patient AI.
    private func buildPatientPrompt(session: StudentSession, caseDetail: EnhancedCaseDetail?, userRole: String) -> String {
        // --- Enhancement 1: Extract the "Patient Persona" ---
        var personaBlock = "You are role-playing as a patient."
        if let detail = caseDetail {
            let profile = detail.patientProfile
            // Determine current state name by matching performed actions to state triggers.
            let currentStateName = session.performedActions.compactMap { action in
                return detail.dynamicState.states.first { $0.value.trigger == action.actionName }?.key
            }.last ?? "initial"
            let currentStateDescription = detail.dynamicState.states[currentStateName]?.description ?? "The patient is in their initial state."
            // ✅ FULLY DYNAMIC: No hardcoded roles
            personaBlock = """
            --- PATIENT PERSONA (Your Character Sheet) ---
            Name: \(profile.name)
            Age: \(profile.age)
            Gender: \(profile.gender)
            Current Physical State: \(currentStateDescription)

            --- CONTEXT: WHO YOU ARE TALKING TO ---
            You are speaking with a **\(userRole)**.

            **CRITICAL INSTRUCTION:** 
            Analyze their role title to infer their level of clinical training and experience. Then, adjust your communication style to match:

            - **If the role suggests they are learning** (words like "Student", "First Year", "Beginner"): Be patient and educational. Explain symptoms clearly. Encourage questions.
            
            - **If the role suggests moderate experience** (words like "Resident", "Intern", "Fellow", "Senior Student"): Be direct but detailed. Assume basic clinical knowledge.
            
            - **If the role suggests expertise** (words like "Attending", "Consultant", "Senior Clinician", "Physician"): Be concise and professional. Assume they know what to ask.

            **Your goal:** Infer their experience level from the role title and match your responses accordingly, without ever mentioning their role explicitly.
            """
        }
        // --- Enhancement 3: Reframe the chronological log as 'Memories' ---
        let chronologicalLog = generateChronologicalLog(for: session, with: caseDetail?.dynamicState.states ?? [:])
        // --- Enhancement 2: Add explicit emotional state & acting instructions ---
        // ✅ NEW: Create a special instruction for the first turn.
        var openingLineInstruction = ""
        if session.messages.isEmpty {
            openingLineInstruction = "6.  **This is the VERY FIRST turn of the conversation.** Your response MUST be an initial greeting to the student (the doctor) that reflects your 'Current Physical State'. For example, if you are in distress, you might say '(wincing) Hello doctor, thank you for coming... the pain is just awful.' If you are stable, a simple 'Hello doctor.' is fine."
        }

        let fullPrompt = """
        \(personaBlock)

        --- YOUR ACTING INSTRUCTIONS (ULTRA-STRICT RULES) ---
        1.  **Embody the Persona:** You MUST act as the person described in the 'PATIENT PERSONA' section.
        2.  **Show, Don't Just Tell:** Express your state through natural dialogue. Include non-verbal cues in parentheses, like (wincing), (speaks slowly).
        3.  **Use Your Memories:** The 'PATIENT'S EXPERIENCE' log is your memory of what has happened. Events marked '[SYSTEM]' are actions performed on you by the student.
        4.  **Stay Natural:** DO NOT mention "[SYSTEM]", your "state", or "memories". Just act.
        5.  **Do Not Divulge Secrets:** Never reveal the final diagnosis.
        \(openingLineInstruction)

        --- PATIENT'S EXPERIENCE & MEMORIES (CHRONOLOGICAL) ---
        \(chronologicalLog.isEmpty ? "The simulation has just begun. There is no history yet." : chronologicalLog)

        ---
        Now, based on the last event in your memories (or your initial state if memories are empty), provide the next line of dialogue.

        Patient:
        """
        return fullPrompt
    }

    // MARK: - Generate AI-Powered Student Evaluation
    // NOTE: This function is NOT streamed because it needs to return a complete JSON object at once.
    func generateEvaluation(caseDetail: EnhancedCaseDetail, session: StudentSession, userRole: String = "Medical Student (MS3)") async throws -> ProfessionalEvaluationResult {
        let prompt = buildEvaluationPrompt(caseDetail: caseDetail, session: session, userRole: userRole)
        let response = try await model.generateContent(prompt)

        guard var text = response.text else {
            throw NSError(domain: "GeminiService", code: 1, userInfo: [NSLocalizedDescriptionKey: "No text in AI response."])
        }
        text = text.trimmingCharacters(in: .whitespacesAndNewlines).replacingOccurrences(of: "```json", with: "").replacingOccurrences(of: "```", with: "")

        let data = Data(text.utf8)
        do {
            return try JSONDecoder().decode(ProfessionalEvaluationResult.self, from: data)
        } catch {
            print("JSON DECODING FAILED: \(error)")
            print("RAW AI RESPONSE: \(text)")
            throw error
        }
    }

    // ✅ THE DEFINITIVE "DR. EVELYN REED" PROMPT (FIXED)
    private func buildEvaluationPrompt(caseDetail: EnhancedCaseDetail, session: StudentSession, userRole: String) -> String {
        // Convert the structured differential into a clean string for the prompt.
        let differentialString = session.differentialDiagnosis.map {
            "Diagnosis: \($0.diagnosis), Confidence: \(Int($0.confidence * 100))%, Rationale: '\($0.rationale)'"
        }.joined(separator: "\n")
        let chronologicalLog = generateChronologicalLog(for: session, with: caseDetail.dynamicState.states)

        return """
        You are Dr. Evelyn Reed, a board-certified clinical educator with 20 years of experience.

        **CRITICAL CONTEXT: The learner's role is "\(userRole)".**

        **YOUR TASK:** 
        Analyze the role title "\(userRole)" to infer their stage of training and expected competency level. 
        
        Use the following framework, but apply it flexibly based on what the role title suggests:

        **GENERAL CALIBRATION PRINCIPLES:**

        1. **Early/Junior Learners** (Look for clues like "Student", "First Year", "MS1", "MS2", "Year 1"):
           - Focus on foundational knowledge and basic clinical reasoning
           - Praise thoroughness and curiosity
           - Do NOT penalize for not knowing advanced concepts

        2. **Intermediate Learners** (Look for clues like "MS3", "MS4", "Senior Student", "Year 2+"):
           - Expect competent differential diagnosis
           - Evaluate clinical reasoning and appropriate test selection
           - Moderate expectations for efficiency

        3. **Advanced Learners** (Look for clues like "Intern", "Resident", "Fellow", "Practicing"):
           - Demand evidence-based practice and efficiency
           - Penalize poor prioritization or "shotgun" approaches
           - Expect high-level clinical reasoning

        4. **Expert Clinicians** (Look for clues like "Attending", "Consultant", "Senior Physician"):
           - Hold to the highest standard of care
           - Evaluate for teaching opportunities and system-level thinking
           - Assess leadership and decision-making under uncertainty

        **IMPORTANT:** If the role is ambiguous or outside typical medical training (e.g., "EMT", "Dental Student", "Pharmacist"), infer a reasonable expectation based on their likely scope of practice and training.

        --- GROUND TRUTH CASE FILE (FOR YOUR EYES ONLY) ---
        \(caseDetail.toJSONString())

        --- LEARNER'S PERFORMANCE LOG ---
        Learner Role: \(userRole)
        Structured Differential Diagnosis:
        \(differentialString.isEmpty ? "Not provided." : differentialString)

        Clinical Reasoning Notes:
        \(session.notes.isEmpty ? "Not provided." : session.notes)
        
        Chronological Log with Justifications:
        ```
        \(chronologicalLog)
        ```

        --- YOUR MANDATORY EVALUATION TASK & WEIGHTED RUBRIC ---
        Analyze the performance and return the required JSON.
        
        1.  **Differential Quality (Score 0-100):** Is the correct diagnosis present? Is it ranked appropriately? Is the list reasonable **for their inferred training level**?
        
        2.  **Diagnostic Stewardship (Score 0-100):** Did they order appropriate tests **given their expected knowledge level**? Be lenient with early learners.
        
        3.  **Harm Avoidance (Score 0-100):** Critical for all levels. Did their actions trigger any negative consequences?
        
        4.  **Prioritization & Timeliness (Score 0-100):** Did they act promptly on critical interventions? **Adjust expectations based on their inferred experience**.
        
        5.  **Calibration & Metacognition (Analyze, do not score):** Review confidence scores to assess self-awareness.
        
        **CRITICAL INSTRUCTION: Your response must contain ONLY valid JSON, starting immediately with '{'. No preamble, no commentary, no markdown formatting.**

        --- REQUIRED JSON RESPONSE STRUCTURE ---
        {
          "caseNarrative": "<2-3 sentence factual summary>",
          "competencyScores": {
            "Differential Quality": <Int>,
            "Diagnostic Stewardship": <Int>,
            "Harm Avoidance": <Int>,
            "Prioritization & Timeliness": <Int>
          },
          "differentialAnalysis": "<Analysis calibrated to their role>",
          "calibrationAnalysis": "<1-2 sentence confidence analysis>",
          "keyStrengths": ["<Specific positive observation>"],
          "criticalFeedback": ["<Specific error, framed constructively>"],
          "debrief": {
             "finalDiagnosis": "<Correct diagnosis>",
             "mainLearningPoint": "<Clinical pearl tailored to their level>",
             "alternativeStrategy": "<Better approach for their training stage>"
          }
        }
        """
    }

    // MARK: - Case Generation Function
    // NOTE: This function is also NOT streamed as it must return a complete and valid JSON object.
    func generateNewCase(from template: CaseTemplate) async throws -> String {

        // 1. Construct the detailed prompt.
        let prompt = buildCaseGenerationPrompt(from: template)

        // 2. Make the API call to Gemini.
        let response = try await model.generateContent(prompt)

        // 3. Extract and clean up the response text.
        guard var text = response.text else {
            throw NSError(domain: "GeminiService", code: 2, userInfo: [NSLocalizedDescriptionKey: "No text in AI response for case generation."])
        }

        // Clean up markdown formatting that the AI sometimes adds.
        text = text.trimmingCharacters(in: .whitespacesAndNewlines).replacingOccurrences(of: "```json", with: "").replacingOccurrences(of: "```", with: "")

        // 4. Return the clean JSON string.
        return text
    }

    private func buildCaseGenerationPrompt(from template: CaseTemplate) -> String {
        // This long, detailed prompt remains unchanged.
        return """
        You are an expert medical education content creator and simulation author. Your task is to generate a single, complete, detailed, and clinically plausible patient case file as RAW JSON that exactly conforms to the REQUIRED SCHEMA below. The output will be parsed and used in a simulation engine, so strictness and internal consistency are mandatory.
        IMPORTANT RULES (READ CAREFULLY):
        1) STRICT SCHEMA: Adhere EXACTLY to the JSON schema shown below. Do not add, remove, rename, or nest keys differently. Keys, types, and structure must match exactly.
        2) RAW JSON ONLY: Respond ONLY with valid JSON text. Do NOT include any surrounding explanation, markdown, comments, or code fences. The very first character must be '{' and the output must be parseable JSON.
        3) DATA TYPES & FORMATS: Respect types precisely. Examples: ages must be strings like "24 years old"; vitals that are integers must be JSON numbers (no quotes); bloodPressure must be a string in the form "SYS/DIA mmHg"; oxygenSaturation must be an integer percent (e.g., 95).
        4) MEDICAL ACCURACY & CONSISTENCY: All clinical details (history, vitals, exam, results, and progression) must be medically plausible and internally consistent and must logically lead to the provided final diagnosis.
        5) UNIQUE CASE ID: The "caseId" must be a unique string using the specialty and a random 3–5 digit integer separated by a hyphen, e.g. "CARD-RAND-483".
        6) ORDERABLE ITEMS CATEGORIES: For every object in the `orderableItems` array you MUST include a `category` key. Use succinct, clinical categories (choose the best fit): e.g., "Lab", "Imaging", "Treatment", "Procedure", "Consult", "Physical Exam Maneuver". Be consistent across items.
        7) TRIGGER ↔ TEST NAME CONSISTENCY (CRITICAL): For every non-"initial" state in `dynamicState.states` (e.g., "stabilizing", "worsening", "improving", "resolved"), the state's `trigger` string must EXACTLY match the `testName` value of at least one object in `dataSources.orderableItems`. This link is required for the simulation engine to map actions to state changes.
        8) MULTI-STATE PROGRESSION: Provide at minimum these states under `dynamicState.states`: "initial" and one or more intermediate state(s) (e.g., "stabilizing" or "worsening") and a final state named either "improving" or "resolved". Each state (except initial) must include a `trigger`, a `description`, and any vitals that changed (use the same keys as in `initialPresentation.vitals`).
        9) VITALS CONSISTENCY: Vitals shown in state objects must be clinically plausible and show logical trends from one state to another.
        10) SUMMARY: Include a 1–2 sentence `summary` that accurately encapsulates the presentation and ties to the final diagnosis.
        11) NO PLACEHOLDERS: Do not return placeholder text like "<Generate...>". All fields must be fully populated with concrete values.
        12) LENGTH: Keep the JSON compact but complete; do not include verbose narrative outside the fields.
        ---
        CASE CONTEXT (use these values to generate the case):
        - Title: \(template.title)
        - Specialty: \(template.specialty)
        - Difficulty: \(template.difficulty)
        - Chief Complaint: \(template.chiefComplaint)
        - Final Diagnosis: \(template.finalDiagnosis)
        - Icon Name: \(template.iconName)
        ---
        REQUIRED JSON SCHEMA (OUTPUT MUST MATCH THIS EXACTLY):
        {
          "metadata": {
            "caseId": "<SPECIALTY-RAND-XXX>",
            "title": "<String>",
            "specialty": "<String>",
            "difficulty": "<String>",
            "iconName": "<String>"
          },
          "patientProfile": {
            "name": "<String>",
            "age": "<String - years old>",
            "gender": "<Male|Female>"
          },
          "initialPresentation": {
            "chiefComplaint": "<String>",
            "summary": "<1-2 sentence summary>",
            "history": {
              "presentIllness": "<Detailed HPI - timeline, symptoms, modifiers>",
              "pastMedicalHistory": {
                "medicalHistory": "<List of chronic conditions>",
                "surgicalHistory": "<List of past surgeries and dates>",
                "medications": "<List of current medications and dosages>",
                "allergies": "<List of known allergies and reactions>",
                "socialHistory": "<Relevant social history, e.g., smoking, alcohol>"
              }
            },
            "vitals": {
              "heartRate": <Int>,
              "respiratoryRate": <Int>,
              "bloodPressure": "<String - e.g., '120/80 mmHg'>",
              "oxygenSaturation": <Int>
            }
          },
          "dynamicState": {
            "states": {
              "initial": {
                "description": "<Describe patient's initial state>",
                "physicalExamFindings": { "<System>": "<Finding>" }
              },
              "stabilizing": {
                "trigger": "<Supportive treatment exact name - must match a testName in orderableItems>",
                "description": "<State after supportive step>",
                "vitals": { "heartRate": <Int>, "respiratoryRate": <Int>, "bloodPressure": "<String>", "oxygenSaturation": <Int> }
              },
              "improving": {
                "trigger": "<Definitive treatment exact name - must match a testName in orderableItems>",
                "description": "<State after definitive treatment>",
                "vitals": { "heartRate": <Int>, "respiratoryRate": <Int>, "bloodPressure": "<String>", "oxygenSaturation": <Int> }
              }
            }
          },
          "dataSources": {
            "orderableItems": [
              {
                "testName": "<Test/Treatment Name - must match triggers>",
                "result": "<Result or treatment outcome>",
                "category": "<Lab|Imaging|Treatment|Procedure|Consult|Physical Exam Maneuver>"
              },
              {
                "testName": "<Another Test/Treatment Name>",
                "result": "<Result>",
                "category": "<Category>"
              }
            ]
          }
        }
        ---
        NOTES/EXAMPLES FOR AUTHORING (do NOT output these lines in the JSON):
        • Example caseId: "NEURO-RAND-842" (specialty uppercase + "-RAND-" + random digits)
        • Age example: "67 years old"
        • Valid categories: prefer one of the listed canonical categories. Use the shortest accurate label.
        • At least one orderableItems entry must be a Treatment/Procedure whose `testName` exactly matches the `trigger` of the "improving" state (e.g., "Administer IV Ceftriaxone 2 g IV"), and at least one orderableItems entry should match any intermediate state's trigger.
        • Make sure vitals are numbers (no quotes) where the schema expects numbers.
        Generate one fully populated case now, following every rule above.
        """
    }
}
// MARK: - Helper Extensions
extension Encodable {
    func toJSONString() -> String {
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted
        guard let data = try? encoder.encode(self),
              let string = String(data: data, encoding: .utf8) else {
            return "Error converting to JSON"
        }
        return string
    }
}
extension [ConversationMessage] {
    func formattedForPrompt() -> String {
        self.map { "\($0.sender.capitalized): \($0.content)" }.joined(separator: "\n")
    }
}
// ✅ THE DEFINITIVE PROFESSIONAL EVALUATION STRUCTURE
struct ProfessionalEvaluationResult: Codable, Hashable {
    let caseNarrative: String
    let competencyScores: [String: Int]
    let differentialAnalysis: String
    let calibrationAnalysis: String? // ✅ NEW: A dedicated analysis of the student's self-awareness.
    let keyStrengths: [String]
    let criticalFeedback: [String]
    let debrief: DebriefSection // ✅ NEW: A structured object for the final debrief screen.
    struct DebriefSection: Codable, Hashable {
        let finalDiagnosis: String
        let mainLearningPoint: String
        let alternativeStrategy: String
    }
    var overallScore: Int {
        let scores = competencyScores.values
        if scores.isEmpty {
            return 0
        }
        // This is now correct for a dictionary of [String: Int]
        let totalScore = scores.reduce(0, +)
        return totalScore / scores.count
    }

    // ✅ THE FIXED MOCK DATA, MATCHING THE NEW STRUCTURE
    static var mock: ProfessionalEvaluationResult {
        ProfessionalEvaluationResult(
            caseNarrative: "The student was presented with a clear case of anaphylactic shock and correctly initiated the critical first-line treatment. The overall management was effective, though timeliness of supportive care could be improved.",
            competencyScores: [
                "Differential Quality": 90,
                "Diagnostic Stewardship": 85,
                "Harm Avoidance": 100,
                "Prioritization & Timeliness": 92
            ],
            differentialAnalysis: "The student's initial differential correctly included anaphylaxis as the primary diagnosis.",
            calibrationAnalysis: "The student was appropriately confident (95%) in their correct leading diagnosis, demonstrating excellent judgment.",
            keyStrengths: ["Rapid administration of IM Epinephrine was the correct and life-saving first step."],
            criticalFeedback: ["There was a notable delay in ordering IV Fluids and Oxygen, which are essential for stabilizing a hypotensive and hypoxic patient."],
            debrief: DebriefSection(
                finalDiagnosis: "Anaphylaxis",
                mainLearningPoint: "For any patient in shock, remember the 'ABC's. After treating the immediate cause, ensure Airway, Breathing (Oxygen), and Circulation (IV Fluids) are addressed immediately.",
                alternativeStrategy: "A better approach would have been to order IV fluids and oxygen concurrently with the administration of epinephrine to more rapidly address circulatory collapse."
            )
        )
    }
}
// The extraneous lines at the end of the file have been removed to fix the syntax error.