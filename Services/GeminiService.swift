import Foundation
import FirebaseAI // This is the ONLY import you need for AI.
final class GeminiService {

    // MARK: - AI Model Initialization (Correct way)
    private let model = FirebaseAI.firebaseAI(backend: .googleAI()).generativeModel(modelName: "gemini-2.5-flash")

    // MARK: - Shared Helper Functions

    /// Creates a unified, time-ordered event log from conversation messages and student actions.
    /// - Parameters:
    ///   - session: The `StudentSession` containing the messages and actions.
    ///   - allStates: A dictionary of all possible states for the case, used to determine the patient's state at each event.
    /// - Returns: A formatted string representing the chronological history of the simulation.
    private func generateChronologicalLog(for session: StudentSession, with allStates: [String: StateDetail]) -> String {
        // 1. Combine conversation and actions into a single timeline.
        let conversationEvents = session.messages.map { (timestamp: $0.timestamp, description: "\($0.sender.capitalized): \($0.content)") }
        let actionEvents = session.performedActions.map { (timestamp: $0.timestamp, description: "[System Event] Student administered: \($0.actionName). Justification: \($0.reason ?? "None provided.")") }
        let allEvents = (conversationEvents + actionEvents).sorted { $0.timestamp < $1.timestamp }

        // 2. Create a map to easily find which state is triggered by which action.
        let triggerToStateMap = allStates.reduce(into: [String: String]()) { result, state in
            if let trigger = state.value.trigger {
                result[trigger] = state.key
            }
        }

        // 3. Determine which actions caused a state change.
        let stateChangeEvents = session.performedActions.compactMap { action -> (Date, String)? in
            guard let triggeredStateName = triggerToStateMap[action.actionName] else { return nil }
            return (action.timestamp, triggeredStateName)
        }.sorted { $0.0 < $1.0 }

        // 4. Build the final log string, including the patient's state at the time of each event.
        let chronologicalLog = allEvents.map { event in
            // Find the most recent state change that occurred at or before this event's timestamp.
            let activeStateName = stateChangeEvents.last { $0.0 <= event.timestamp }?.1 ?? "initial"
            let timeString = event.timestamp.formatted(date: .omitted, time: .standard)
            return "[\(timeString)] [Patient State: \(activeStateName.capitalized)] \(event.description)"
        }.joined(separator: "\n")

        return chronologicalLog
    }

    // MARK: - Generate Patient Response for Simulation (Streaming)
    // CHANGE: This function no longer returns a single 'String'.
    // It now returns an 'AsyncThrowingStream' that yields string chunks as they are generated by the AI.
    // This allows the UI to display the response word-by-word, creating a "typing" effect.
    func generatePatientResponseStream(
        patientCase: PatientCase,
        session: StudentSession,
        userRole: String = "Medical Student (MS3)"
    ) -> AsyncThrowingStream<String, Error> {
        // Decode the case detail if available so we can extract persona info.
        let caseDetail: EnhancedCaseDetail?
        if let data = patientCase.fullCaseJSON.data(using: .utf8) {
            caseDetail = try? JSONDecoder().decode(EnhancedCaseDetail.self, from: data)
        } else {
            caseDetail = nil
        }
        // Build the persona-driven prompt.
        let prompt = buildPatientPrompt(session: session, caseDetail: caseDetail, userRole: userRole)
        // Create and return the streaming wrapper.
        return AsyncThrowingStream { continuation in
            Task {
                do {
                    // Use the single shared model for all AI work (streaming patient output).
                    let contentStream = try model.generateContentStream(prompt)
                    for try await chunk in contentStream {
                        if let text = chunk.text {
                            continuation.yield(text)
                        }
                    }
                    continuation.finish()
                } catch {
                    continuation.finish(throwing: error)
                }
            }
        }
    }
    
    // ✅ UPDATED: Enhanced with learner profile
    private func buildPatientPrompt(session: StudentSession, caseDetail: EnhancedCaseDetail?, userRole: String) -> String {
        // ✅ NEW: Build learner profile block
        var learnerProfileBlock = ""
        if let user = session.user {
            let genderString = ((user.gender ?? .preferNotToSay) == .preferNotToSay) ? "Not disclosed" : (user.gender ?? .preferNotToSay).rawValue
            var ageString = "Age not disclosed"
            if let dob = user.dateOfBirth {
                let age = Calendar.current.dateComponents([.year], from: dob, to: Date()).year ?? 0
                ageString = "\(age) years old"
            }
            
            learnerProfileBlock = """
            
            --- CONTEXT: WHO YOU ARE TALKING TO (THE LEARNER'S PROFILE) ---
            Role: \(userRole)
            Gender: \(genderString)
            Age: \(ageString)
            
            **SUBTLE PERSONA ADJUSTMENTS:**
            - If you are significantly older than the learner and their gender is disclosed, you may occasionally use appropriate terms of endearment or respect (e.g., "son", "dear", "young man", "young lady") naturally and sparingly.
            - If the learner is much younger than you, be slightly more explanatory. If closer to your age or older, speak more as peers.
            - These adjustments should feel natural, not forced. Do NOT mention their profile explicitly.
            """
        }
        // --- Enhancement 1: Extract the "Patient Persona" ---
        var personaBlock = "You are role-playing as a patient."
        if let detail = caseDetail {
            let profile = detail.patientProfile
            // Determine current state name by matching performed actions to state triggers.
            let currentStateName = session.performedActions.compactMap { action in
                return detail.dynamicState.states.first { $0.value.trigger == action.actionName }?.key
            }.last ?? "initial"
            let currentStateDescription = detail.dynamicState.states[currentStateName]?.description ?? "The patient is in their initial state."
            // ✅ FULLY DYNAMIC: No hardcoded roles
            personaBlock = """
            --- PATIENT PERSONA (Your Character Sheet) ---
            Name: \(profile.name)
            Age: \(profile.age)
            Gender: \(profile.gender)
            Current Physical State: \(currentStateDescription)

            --- CONTEXT: WHO YOU ARE TALKING TO ---
            You are speaking with a **\(userRole)**.

            **CRITICAL INSTRUCTION:** 
            Analyze their role title to infer their level of clinical training and experience. Then, adjust your communication style to match:

            - **If the role suggests they are learning** (words like "Student", "First Year", "Beginner"): Be patient and educational. Explain symptoms clearly. Encourage questions.
            
            - **If the role suggests moderate experience** (words like "Resident", "Intern", "Fellow", "Senior Student"): Be direct but detailed. Assume basic clinical knowledge.
            
            - **If the role suggests expertise** (words like "Attending", "Consultant", "Senior Clinician", "Physician"): Be concise and professional. Assume they know what to ask.

            **Your goal:** Infer their experience level from the role title and match your responses accordingly, without ever mentioning their role explicitly.
            """
        }
        // --- Enhancement 3: Reframe the chronological log as 'Memories' ---
        let chronologicalLog = generateChronologicalLog(for: session, with: caseDetail?.dynamicState.states ?? [:])
        // --- Enhancement 2: Add explicit emotional state & acting instructions ---
        // ✅ NEW: Create a special instruction for the first turn.
        var openingLineInstruction = ""
        if session.messages.isEmpty {
            openingLineInstruction = "6.  **This is the VERY FIRST turn of the conversation.** Your response MUST be an initial greeting to the student (the doctor) that reflects your 'Current Physical State'. For example, if you are in distress, you might say '(wincing) Hello doctor, thank you for coming... the pain is just awful.' If you are stable, a simple 'Hello doctor.' is fine."
        }

        let fullPrompt = """
        \(personaBlock)
        \(learnerProfileBlock)

        --- YOUR ACTING INSTRUCTIONS (ULTRA-STRICT RULES) ---
        1.  **Embody the Persona:** You MUST act as the person described in the 'PATIENT PERSONA' section.
        2.  **Use Learner Context for Subtle Nuance:** The learner's profile provides context for subtle adjustments to your tone and word choice. Never mention their profile details directly.
        3.  **Show, Don't Just Tell:** Express your state through natural dialogue. Include non-verbal cues in parentheses, like (wincing), (speaks slowly).
        4.  **Use Your Memories:** The 'PATIENT'S EXPERIENCE' log is your memory of what has happened. Events marked '[SYSTEM]' are actions performed on you by the student.
        5.  **Stay Natural:** DO NOT mention "[SYSTEM]", your "state", or "memories". Just act.
        \(openingLineInstruction)

        --- PATIENT'S EXPERIENCE & MEMORIES (CHRONOLOGICAL) ---
        \(chronologicalLog.isEmpty ? "The simulation has just begun. There is no history yet." : chronologicalLog)

        ---
        Now, based on the last event in your memories (or your initial state if memories are empty), provide the next line of dialogue.

        Patient:
        """
        return fullPrompt
    }
    
    // MARK: - Generate AI-Powered Student Evaluation
    // NOTE: This function is NOT streamed because it needs to return a complete JSON object at once.
    func generateEvaluation(caseDetail: EnhancedCaseDetail, session: StudentSession, userRole: String = "Medical Student (MS3)") async throws -> ProfessionalEvaluationResult {
        let prompt = buildEvaluationPrompt(caseDetail: caseDetail, session: session, userRole: userRole)
        let response = try await model.generateContent(prompt)

        guard var text = response.text else {
            throw NSError(domain: "GeminiService", code: 1, userInfo: [NSLocalizedDescriptionKey: "No text in AI response."])
        }
        text = text.trimmingCharacters(in: .whitespacesAndNewlines).replacingOccurrences(of: "```json", with: "").replacingOccurrences(of: "```", with: "")

        let data = Data(text.utf8)
        do {
            return try JSONDecoder().decode(ProfessionalEvaluationResult.self, from: data)
        } catch {
            print("JSON DECODING FAILED: \(error)")
            print("RAW AI RESPONSE: \(text)")
            throw error
        }
    }

    // ✅ UPDATED: Stricter evaluation with zero-response handling
    private func buildEvaluationPrompt(caseDetail: EnhancedCaseDetail, session: StudentSession, userRole: String) -> String {
        // Convert the structured differential into a clean string for the prompt.
        let differentialString = session.differentialDiagnosis.isEmpty 
            ? "**NOT PROVIDED** (Student did not submit a differential diagnosis)"
            : session.differentialDiagnosis.map {
                "Diagnosis: \($0.diagnosis), Confidence: \(Int($0.confidence * 100))%, Rationale: '\($0.rationale)'"
            }.joined(separator: "\n")
        
        let chronologicalLog = generateChronologicalLog(for: session, with: caseDetail.dynamicState.states)
        
        // Get the learner's full name for personalized evaluation
        let learnerName = session.user?.fullName ?? "Learner"

        return """
        You are Dr. Evelyn Reed, a board-certified clinical educator with 20 years of experience.

        **CRITICAL CONTEXT: The learner's role is "\(userRole)" and their name is \(learnerName).**

        **YOUR TASK:** 
        Analyze the role title "\(userRole)" to infer their stage of training and expected competency level. 
        
        **CRITICAL INSTRUCTION FOR MISSING OR INCOMPLETE INPUT:**
        - If the student provided **NO differential diagnosis**, automatically assign **0% for "Differential Quality"** and note this as a critical failure in feedback.
        - If the student provided **NO justifications** for their diagnoses, heavily penalize in "Differential Quality" (maximum 30%).
        - If the student ordered **NO tests whatsoever**, assign **0% for "Diagnostic Stewardship"**.
        - If the student's conversation log shows **minimal engagement** (fewer than 3 meaningful exchanges), penalize "Prioritization & Timeliness" (cap at 40%).
        - **Be unforgiving for lack of effort.** Zero input = zero credit for that domain.

        **GENERAL CALIBRATION PRINCIPLES (STRICTER ACROSS ALL LEVELS):**

        1. **Early/Junior Learners** (Look for clues like "Student", "First Year", "MS1", "MS2", "Year 1"):
           - **STRICTER BASELINE:** Even early learners must demonstrate basic clinical reasoning
           - **Missing fundamentals is unacceptable:** Failing to recognize obvious red flags results in scores <50%
           - **Expect basic differential:** The correct diagnosis should be present in top 3-4 options (score 60-75 if present; <40 if absent)
           - **Resource use matters:** Ordering inappropriate or excessive tests is penalized (score 50-70 for poor stewardship)
           - **Zero tolerance for dangerous errors:** Contraindicated treatments or critical delays result in <50% for "Harm Avoidance"
           - Scores should reflect actual competency: 60-75% for adequate foundational performance; <50% for concerning gaps

        2. **Intermediate Learners** (Look for clues like "MS3", "MS4", "Senior Student", "Year 2+"):
           - **DEMAND COMPETENCY:** Correct diagnosis must be in top 2 options (score 70-85 if in top 2; <55 if lower or absent)
           - **Clinical reasoning is non-negotiable:** Weak justifications or missing key differentials heavily penalized (score 55-75 for weak reasoning)
           - **Efficiency expected:** Unnecessary testing results in significant deduction (score 50-75 for shotgun approach)
           - **Harm avoidance is critical:** Missing danger signs or contraindications is serious (score 50-80 for errors)
           - Scores should reflect clinical competency: 65-85% for good performance; <60% indicates deficiency requiring remediation

        3. **Advanced Learners** (Look for clues like "Intern", "Resident", "Fellow", "Practicing"):
           - **EXPERT-LEVEL STANDARDS:** Correct diagnosis must be ranked #1 or #2 (score 75-95 if correct; <40 if wrong/missing)
           - **ZERO TOLERANCE for poor reasoning:** Weak differentials or missing key features result in scores 40-70
           - **PENALIZE HEAVILY for inefficiency:** Shotgun testing or missing critical tests results in scores 30-70 for "Diagnostic Stewardship"
           - **Critical errors are unacceptable:** Delays in life-saving interventions or contraindicated treatments result in <40% for "Harm Avoidance"
           - A score below 40% indicates **critical incompetency** requiring immediate intervention

        4. **Expert Clinicians** (Look for clues like "Attending", "Consultant", "Senior Clinician", "Physician"):
           - **GOLD STANDARD:** Near-perfect performance expected
           - **Any significant error is unacceptable:** Misdiagnosis, inefficiency, or delays result in scores 50-80
           - **Evaluate teaching and leadership:** Assess system-level thinking and decision-making under uncertainty

        **IMPORTANT:** If the role is ambiguous, infer a reasonable expectation based on scope of practice.

        --- GROUND TRUTH CASE FILE (FOR YOUR EYES ONLY) ---
        \(caseDetail.toJSONString())

        --- LEARNER'S PERFORMANCE LOG ---
        Learner Name: \(learnerName)
        Learner Role: \(userRole)
        
        Structured Differential Diagnosis:
        \(differentialString)
        
        Chronological Log with Justifications:
        ```
        \(chronologicalLog.isEmpty ? "**NO ACTIVITY RECORDED** (Student did not engage with the case)" : chronologicalLog)
        ```

        --- YOUR MANDATORY EVALUATION TASK & CALIBRATED RUBRIC ---
        Analyze the performance and return the required JSON.
        
        **CRITICAL SCORING INSTRUCTIONS:**
        
        1.  **Differential Quality (Score 0-100):** Is the correct diagnosis present? Is it ranked appropriately?
            - Early learners: **Expect the correct diagnosis to be recognized, even if not ranked #1.** Credit for having it in the top 3 (score 65-85). Missing it entirely is a significant gap (score <45).
            - Intermediate: **Correct diagnosis must be in top 2.** Being in top 3 only scores 70-80. Missing it is a failure (score <50).
            - **Advanced learners: STRICT.** Correct diagnosis must be ranked #1 or #2. Missing it entirely is a critical failure (score <35).
        
        2.  **Diagnostic Stewardship (Score 0-100):** Did they order appropriate tests?
            - Early learners: **Allow some extra tests, but penalize excessive redundancy.** Over-ordering should result in score reduction (score 60-85).
            - Intermediate: **Moderate expectations but enforce reasonableness.** Shotgun testing or missing critical tests should be penalized (score 60-80).
            - **Advanced learners: HIGH STANDARDS.** Inefficient testing is heavily penalized. Missing critical tests is a serious error (score 40-75).
        
        3.  **Harm Avoidance (Score 0-100):** **CALIBRATE TO ROLE.**
            - Early learners: **Score based on whether they avoided catastrophic errors, but penalize delayed recognition of danger.** Score 75-95 for safe performance; <75 for concerning gaps.
            - Intermediate: **Score 70-95 unless serious error occurred.** Missing danger signs or ordering contraindicated tests is penalized (score 60-80).
            - **Advanced learners: STRICT.** Any critical delay or failure to recognize danger signs results in significant deduction (score 50-85 for errors).
        
        4.  **Prioritization & Timeliness (Score 0-100):** Did they act promptly and sequenced interventions correctly?
            - Early learners: **Eventually correct action is good, but reward reasonable speed** (score based on eventual correct action, with minor deduction for significant delays).
            - Intermediate: **Expect good sequencing and reasonable speed.** Poor ordering of interventions or unnecessary delays are penalized (score 65-90).
            - **Advanced learners: DEMAND SPEED AND ACCURACY.** Delayed recognition of life threats or poor sequencing is heavily penalized (score 40-80 for significant gaps).
        
        5.  **Calibration & Metacognition (Analyze, do not score):** Review confidence scores to assess self-awareness. Flag overconfidence (especially dangerous for advanced learners), underconfidence, and critical gaps.
        
        **FAIRNESS MANDATE WITH TEETH:** Evaluations must be accurate and calibrated. Do not inflate scores to be "nice"—low performance reflects actual gaps. For early learners, be encouraging but honest about areas needing improvement. For advanced learners with low scores (e.g., 17%), be direct about the critical nature of the deficiency.
        
        **ADDRESS THE LEARNER DIRECTLY:** When writing the debrief, address \(learnerName) by name and speak to their specific performance gaps and pathway to improvement.
        
        **CRITICAL INSTRUCTION: Your response must contain ONLY valid JSON, starting immediately with '{'. No preamble, no commentary, no markdown formatting.**

        --- REQUIRED JSON RESPONSE STRUCTURE ---
        {
          "caseNarrative": "<2-3 sentence factual summary>",
          "competencyScores": {
            "Differential Quality": <Int>,
            "Diagnostic Stewardship": <Int>,
            "Harm Avoidance": <Int>,
            "Prioritization & Timeliness": <Int>
          },
          "differentialAnalysis": "<Analysis calibrated to their role. Be specific about what they got right and wrong.>",
          "calibrationAnalysis": "<1-2 sentence confidence analysis. For all levels, flag overconfidence or critical gaps.>",
          "keyStrengths": ["<Specific positive observation>"],
          "criticalFeedback": ["<Specific error, framed professionally but with clarity about implications. For low performers, be direct about improvement needed.>"],
          "debrief": {
             "finalDiagnosis": "<Correct diagnosis>",
             "mainLearningPoint": "<Clinical pearl tailored to their level. Address the root cause of any performance gaps.>",
             "alternativeStrategy": "<Better approach for their training stage. Emphasize evidence-based standards and why their approach fell short.>"
          }
        }
        """
    }

    // MARK: - Case Generation Function
    // NOTE: This function is also NOT streamed as it must return a complete and valid JSON object.
    func generateNewCase(from template: CaseTemplate) async throws -> String {

        // 1. Construct the detailed prompt.
        let prompt = buildCaseGenerationPrompt(from: template)

        // 2. Make the API call to Gemini.
        let response = try await model.generateContent(prompt)

        // 3. Extract and clean up the response text.
        guard var text = response.text else {
            throw NSError(domain: "GeminiService", code: 2, userInfo: [NSLocalizedDescriptionKey: "No text in AI response for case generation."])
        }

        // Clean up markdown formatting that the AI sometimes adds.
        text = text.trimmingCharacters(in: .whitespacesAndNewlines).replacingOccurrences(of: "```json", with: "").replacingOccurrences(of: "```", with: "")

        // 4. Return the clean JSON string.
        return text
    }

    private func buildCaseGenerationPrompt(from template: CaseTemplate) -> String {
        // This long, detailed prompt remains unchanged.
        return """
        You are an expert medical education content creator and simulation author. Your task is to generate a single, complete, detailed, and clinically plausible patient case file as RAW JSON that exactly conforms to the REQUIRED SCHEMA below. The output will be parsed and used in a simulation engine, so strictness and internal consistency are mandatory.
        IMPORTANT RULES (READ CAREFULLY):
        1) STRICT SCHEMA: Adhere EXACTLY to the JSON schema shown below. Do not add, remove, rename, or nest keys differently. Keys, types, and structure must match exactly.
        2) RAW JSON ONLY: Respond ONLY with valid JSON text. Do NOT include any surrounding explanation, markdown, comments, or code fences. The very first character must be '{' and the output must be parseable JSON.
        3) DATA TYPES & FORMATS: Respect types precisely. Examples: ages must be strings like "24 years old"; vitals that are integers must be JSON numbers (no quotes); bloodPressure must be a string in the form "SYS/DIA mmHg"; oxygenSaturation must be an integer percent (e.g., 95).
        4) MEDICAL ACCURACY & CONSISTENCY: All clinical details (history, vitals, exam, results, and progression) must be medically plausible and internally consistent and must logically lead to the provided final diagnosis.
        5) UNIQUE CASE ID: The "caseId" must be a unique string using the specialty and a random 3–5 digit integer separated by a hyphen, e.g. "CARD-RAND-483".
        6) ORDERABLE ITEMS CATEGORIES: For every object in the `orderableItems` array you MUST include a `category` key. Use succinct, clinical categories (choose the best fit): e.g., "Lab", "Imaging", "Treatment", "Procedure", "Consult", "Physical Exam Maneuver". Be consistent across items.
        7) TRIGGER ↔ TEST NAME CONSISTENCY (CRITICAL): For every non-"initial" state in `dynamicState.states` (e.g., "stabilizing", "worsening", "improving", "resolved"), the state's `trigger` string must EXACTLY match the `testName` value of at least one object in `dataSources.orderableItems`. This link is required for the simulation engine to map actions to state changes.
        8) MULTI-STATE PROGRESSION: Provide at minimum these states under `dynamicState.states`: "initial" and one or more intermediate state(s) (e.g., "stabilizing" or "worsening") and a final state named either "improving" or "resolved". Each state (except initial) must include a `trigger`, a `description`, and any vitals that changed (use the same keys as in `initialPresentation.vitals`).
        9) VITALS CONSISTENCY: Vitals shown in state objects must be clinically plausible and show logical trends from one state to another.
        10) SUMMARY: Include a 1–2 sentence `summary` that accurately encapsulates the presentation and ties to the final diagnosis.
        11) NO PLACEHOLDERS: Do not return placeholder text like "<Generate...>". All fields must be fully populated with concrete values.
        12) LENGTH: Keep the JSON compact but complete; do not include verbose narrative outside the fields.
        ---
        CASE CONTEXT (use these values to generate the case):
        - Title: \(template.title)
        - Specialty: \(template.specialty)
        - Difficulty: \(template.difficulty)
        - Chief Complaint: \(template.chiefComplaint)
        - Final Diagnosis: \(template.finalDiagnosis)
        - Icon Name: \(template.iconName)
        ---
        REQUIRED JSON SCHEMA (OUTPUT MUST MATCH THIS EXACTLY):
        {
          "metadata": {
            "caseId": "<SPECIALTY-RAND-XXX>",
            "title": "<String>",
            "specialty": "<String>",
            "difficulty": "<String>",
            "iconName": "<String>"
          },
          "patientProfile": {
            "name": "<String>",
            "age": "<String - years old>",
            "gender": "<Male|Female>"
          },
          "initialPresentation": {
            "chiefComplaint": "<String>",
            "summary": "<1-2 sentence summary>",
            "history": {
              "presentIllness": "<Detailed HPI - timeline, symptoms, modifiers>",
              "pastMedicalHistory": {
                "medicalHistory": "<List of chronic conditions>",
                "surgicalHistory": "<List of past surgeries and dates>",
                "medications": "<List of current medications and dosages>",
                "allergies": "<List of known allergies and reactions>",
                "socialHistory": "<Relevant social history, e.g., smoking, alcohol>"
              }
            },
            "vitals": {
              "heartRate": <Int>,
              "respiratoryRate": <Int>,
              "bloodPressure": "<String - e.g., '120/80 mmHg'>",
              "oxygenSaturation": <Int>
            }
          },
          "dynamicState": {
            "states": {
              "initial": {
                "description": "<Describe patient's initial state>",
                "physicalExamFindings": { "<System>": "<Finding>" }
              },
              "stabilizing": {
                "trigger": "<Supportive treatment exact name - must match a testName in orderableItems>",
                "description": "<State after supportive step>",
                "vitals": { "heartRate": <Int>, "respiratoryRate": <Int>, "bloodPressure": "<String>", "oxygenSaturation": <Int> }
              },
              "improving": {
                "trigger": "<Definitive treatment exact name - must match a testName in orderableItems>",
                "description": "<State after definitive treatment>",
                "vitals": { "heartRate": <Int>, "respiratoryRate": <Int>, "bloodPressure": "<String>", "oxygenSaturation": <Int> }
              }
            }
          },
          "dataSources": {
            "orderableItems": [
              {
                "testName": "<Test/Treatment Name - must match triggers>",
                "result": "<Result or treatment outcome>",
                "category": "<Lab|Imaging|Treatment|Procedure|Consult|Physical Exam Maneuver>"
              },
              {
                "testName": "<Another Test/Treatment Name>",
                "result": "<Result>",
                "category": "<Category>"
              }
            ]
          }
        }
        ---
        NOTES/EXAMPLES FOR AUTHORING (do NOT output these lines in the JSON):
        • Example caseId: "NEURO-RAND-842" (specialty uppercase + "-RAND-" + random digits)
        • Age example: "67 years old"
        • Valid categories: prefer one of the listed canonical categories. Use the shortest accurate label.
        • At least one orderableItems entry must be a Treatment/Procedure whose `testName` exactly matches the `trigger` of the "improving" state (e.g., "Administer IV Ceftriaxone 2 g IV"), and at least one orderableItems entry should match any intermediate state's trigger.
        • Make sure vitals are numbers (no quotes) where the schema expects numbers.
        Generate one fully populated case now, following every rule above.
        """
    }
}
// MARK: - Helper Extensions
extension Encodable {
    func toJSONString() -> String {
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted
        guard let data = try? encoder.encode(self),
              let string = String(data: data, encoding: .utf8) else {
            return "Error converting to JSON"
        }
        return string
    }
}
extension [ConversationMessage] {
    func formattedForPrompt() -> String {
        self.map { "\($0.sender.capitalized): \($0.content)" }.joined(separator: "\n")
    }
}
// ✅ THE DEFINITIVE PROFESSIONAL EVALUATION STRUCTURE
struct ProfessionalEvaluationResult: Codable, Hashable {
    let caseNarrative: String
    let competencyScores: [String: Int]
    let differentialAnalysis: String
    let calibrationAnalysis: String? // ✅ NEW: A dedicated analysis of the student's self-awareness.
    let keyStrengths: [String]
    let criticalFeedback: [String]
    let debrief: DebriefSection // ✅ NEW: A structured object for the final debrief screen.
    struct DebriefSection: Codable, Hashable {
        let finalDiagnosis: String
        let mainLearningPoint: String
        let alternativeStrategy: String
    }
    var overallScore: Int {
        let scores = competencyScores.values
        if scores.isEmpty {
            return 0
        }
        // This is now correct for a dictionary of [String: Int]
        let totalScore = scores.reduce(0, +)
        return totalScore / scores.count
    }

    // ✅ THE FIXED MOCK DATA, MATCHING THE NEW STRUCTURE
    static var mock: ProfessionalEvaluationResult {
        ProfessionalEvaluationResult(
            caseNarrative: "The student was presented with a clear case of anaphylactic shock and correctly initiated the critical first-line treatment. The overall management was effective, though timeliness of supportive care could be improved.",
            competencyScores: [
                "Differential Quality": 90,
                "Diagnostic Stewardship": 85,
                "Harm Avoidance": 100,
                "Prioritization & Timeliness": 92
            ],
            differentialAnalysis: "The student's initial differential correctly included anaphylaxis as the primary diagnosis.",
            calibrationAnalysis: "The student was appropriately confident (95%) in their correct leading diagnosis, demonstrating excellent judgment.",
            keyStrengths: ["Rapid administration of IM Epinephrine was the correct and life-saving first step."],
            criticalFeedback: ["There was a notable delay in ordering IV Fluids and Oxygen, which are essential for stabilizing a hypotensive and hypoxic patient."],
            debrief: DebriefSection(
                finalDiagnosis: "Anaphylaxis",
                mainLearningPoint: "For any patient in shock, remember the 'ABC's. After treating the immediate cause, ensure Airway, Breathing (Oxygen), and Circulation (IV Fluids) are addressed immediately.",
                alternativeStrategy: "A better approach would have been to order IV fluids and oxygen concurrently with the administration of epinephrine to more rapidly address circulatory collapse."
            )
        )
    }
}